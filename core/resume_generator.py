"""Resume G-code generator for FailFixer.

Builds a new G-code file in one of two resume modes:
  1. in_air: Resume at/near the failed print height (legacy/default behavior).
  2. from_plate: Rebase selected layer to Z0 so it can be printed on the plate.
"""

from __future__ import annotations

import re
from dataclasses import dataclass
from typing import Literal

from .gcode_parser import ParsedGCode
from .layer_mapper import LayerMatch


ResumeMode = Literal["in_air", "from_plate"]
_RE_Z_PARAM = re.compile(r"(\bZ\s*)([+-]?\d+\.?\d*)", re.IGNORECASE)


@dataclass
class ResumeConfig:
    """User-provided configuration for resume generation."""

    resume_layer: int
    resume_z: float
    bed_temp: float
    nozzle_temp: float
    safe_lift_mm: float = 10.0
    z_offset_mm: float = 0.0
    bed_mesh_cmd: str = "M420 S1"
    resume_mode: ResumeMode = "in_air"


class ResumeGenerator:
    """Generates resume G-code from parsed data + config."""

    def generate(
        self,
        parsed: ParsedGCode,
        match: LayerMatch,
        config: ResumeConfig,
    ) -> list[str]:
        """Return a list of G-code lines (without trailing newlines) for
        the resume file."""
        out: list[str] = []

        layer = match.layer
        start = layer.start_line
        tail_lines = parsed.lines[start:]

        original_filename = getattr(parsed, "source_filename", "unknown")
        metadata_lines = self._extract_visual_and_material_metadata(parsed)

        if config.resume_mode == "from_plate":
            out.extend(
                self._build_from_plate_header(
                    original_filename=original_filename,
                    config=config,
                    start_layer_z=layer.z_height,
                )
            )
            if metadata_lines:
                out.extend(metadata_lines)
                out.append("")
            shifted = [self._shift_z_to_plate(line, layer.z_height) for line in tail_lines]
            out.extend(shifted)
            return out

        out.extend(
            self._build_in_air_header(
                original_filename=original_filename,
                config=config,
            )
        )
        if metadata_lines:
            out.extend(metadata_lines)
            out.append("")
        out.extend(tail_lines)
        return out

    def generate_text(
        self,
        parsed: ParsedGCode,
        match: LayerMatch,
        config: ResumeConfig,
    ) -> str:
        """Convenience: return the resume G-code as a single string."""
        lines = self.generate(parsed, match, config)
        return "\n".join(lines) + "\n"

    def _build_in_air_header(self, original_filename: str, config: ResumeConfig) -> list[str]:
        effective_z = config.resume_z + config.z_offset_mm
        clearance_z = max(config.safe_lift_mm, effective_z + 5.0)

        out: list[str] = []
        out.append("; === FailFixer Resume File ===")
        out.append(f"; Original file: {original_filename}")
        out.append(f"; Resume Mode: in_air")
        out.append(f"; Resume Layer: {config.resume_layer}")
        out.append(f"; Resume Z: {config.resume_z:.3f}")
        out.append(f"; Z Offset: {config.z_offset_mm:.3f}")
        out.append("; Generated by FailFixer V1")
        out.append(";")
        out.append("; SAFETY: This file assumes the nozzle is at or near")
        out.append("; the top of the failed print when started.")
        out.append("")
        out.append("; --- Units & Mode ---")
        out.append("G21                        ; Millimeters")
        out.append("G90                        ; Absolute positioning")
        out.append("M82                        ; Absolute extrusion")
        out.append("")
        out.append("; --- Heat Up ---")
        out.append(f"M140 S{_fmt_temp(config.bed_temp)}           ; Start heating bed")
        out.append(f"M104 S{_fmt_temp(config.nozzle_temp)}        ; Start heating nozzle")
        out.append(f"M190 S{_fmt_temp(config.bed_temp)}           ; Wait for bed temp")
        out.append(f"M109 S{_fmt_temp(config.nozzle_temp)}        ; Wait for nozzle temp")
        out.append("")
        out.append("; --- Safe Homing (XY only) ---")
        out.append("; CRITICAL: Do NOT home Z â€” nozzle would crash into partial print")
        out.append("G28 X Y                    ; Home X and Y at corner")
        out.append("")
        out.append("; --- Set Z Position ---")
        out.append("; Tell firmware where Z is based on the failed layer height")
        out.append("; The nozzle should physically be at/near this height")
        out.append(f"G92 Z{effective_z:.3f}         ; Set current Z = resume height")
        out.append("")
        out.append("; --- Clearance Lift ---")
        out.append("; Move UP before any XY travel to avoid scraping the print")
        out.append(f"G1 Z{clearance_z:.3f} F300     ; Lift to safe clearance height")
        out.append("")
        out.append("; --- Restore Bed Mesh ---")
        out.append(f"{config.bed_mesh_cmd}      ; Enable bed mesh/compensation (skip G29 â€” probing risks collision)")
        out.append("")
        out.append("; --- Prime Nozzle ---")
        out.append("; Extrude at clearance height to get filament flowing")
        out.append("G1 X5 Y5 F3000             ; Move to front-left corner")
        out.append("G92 E0                     ; Reset extruder")
        out.append("G1 E8 F300                 ; Prime 8mm of filament (in the air, safe)")
        out.append("G1 E-0.5 F1800             ; Small retract to prevent ooze")
        out.append("G92 E0                     ; Reset extruder again")
        out.append("")
        out.append(f"; === Resume Print from Layer {config.resume_layer} ===")
        return out

    def _build_from_plate_header(
        self,
        original_filename: str,
        config: ResumeConfig,
        start_layer_z: float,
    ) -> list[str]:
        out: list[str] = []
        out.append("; === FailFixer Resume File ===")
        out.append(f"; Original file: {original_filename}")
        out.append(f"; Resume Mode: from_plate")
        out.append(f"; Resume Layer: {config.resume_layer}")
        out.append(f"; Original Resume Z: {config.resume_z:.3f}")
        out.append(f"; Rebased Start Z: {start_layer_z:.3f} -> 0.000")
        out.append("; Generated by FailFixer V1")
        out.append(";")
        out.append("; This mode prints the selected section from the build plate")
        out.append("; so the replacement section can be glued to the failed part.")
        out.append("")
        out.append("; --- Units & Mode ---")
        out.append("G21                        ; Millimeters")
        out.append("G90                        ; Absolute positioning")
        out.append("M82                        ; Absolute extrusion")
        out.append("")
        out.append("; --- Heat Up ---")
        out.append(f"M140 S{_fmt_temp(config.bed_temp)}           ; Start heating bed")
        out.append(f"M104 S{_fmt_temp(config.nozzle_temp)}        ; Start heating nozzle")
        out.append(f"M190 S{_fmt_temp(config.bed_temp)}           ; Wait for bed temp")
        out.append(f"M109 S{_fmt_temp(config.nozzle_temp)}        ; Wait for nozzle temp")
        out.append("")
        out.append("; --- Standard Homing (safe on empty plate) ---")
        out.append("G28                        ; Home all axes")
        out.append("")
        out.append("; --- Restore Bed Mesh ---")
        out.append(f"{config.bed_mesh_cmd}      ; Enable saved bed mesh")
        out.append("")
        out.append("; --- Prime Nozzle ---")
        out.append("G1 Z0.300 F300             ; Move to first-layer-safe height")
        out.append("G1 X5 Y5 F3000             ; Move to front-left corner")
        out.append("G92 E0                     ; Reset extruder")
        out.append("G1 E8 F300                 ; Prime 8mm filament")
        out.append("G1 E-0.5 F1800             ; Small retract to prevent ooze")
        out.append("G92 E0                     ; Reset extruder again")
        out.append("")
        out.append(
            f"; === Resume Print from Layer {config.resume_layer} (rebased to plate) ==="
        )
        return out

    def _shift_z_to_plate(self, line: str, start_z: float) -> str:
        code, sep, comment = line.partition(";")

        def _replace(m: re.Match[str]) -> str:
            old_z = float(m.group(2))
            new_z = old_z - start_z
            if new_z < 0.0:
                new_z = 0.0
            return f"{m.group(1)}{new_z:.3f}"

        shifted_code = _RE_Z_PARAM.sub(_replace, code)
        return f"{shifted_code}{sep}{comment}" if sep else shifted_code

    def _extract_visual_and_material_metadata(self, parsed: ParsedGCode) -> list[str]:
        """Preserve useful metadata blocks (thumbnail + filament/material comments)
        from the source header so printer UIs (e.g., preview/filament assistants)
        still work on generated files.
        """
        header_end = min(max(parsed.header_end_line, 0), len(parsed.lines))
        if header_end == 0:
            header_end = min(len(parsed.lines), 400)

        out: list[str] = []
        in_thumbnail = False

        for raw in parsed.lines[:header_end]:
            stripped = raw.strip()
            lower = stripped.lower()

            if lower.startswith("; thumbnail begin"):
                in_thumbnail = True
                out.append(raw)
                continue
            if in_thumbnail:
                out.append(raw)
                if lower.startswith("; thumbnail end"):
                    in_thumbnail = False
                continue

            if not stripped.startswith(";"):
                continue

            if any(key in lower for key in (
                "filament",
                "material",
                "nozzle_diameter",
                "layer_height",
                "printer",
                "generated with",
            )):
                out.append(raw)

        # de-dupe while preserving order
        seen: set[str] = set()
        unique: list[str] = []
        for line in out:
            if line in seen:
                continue
            seen.add(line)
            unique.append(line)
        return unique


def _fmt_temp(temp: float) -> str:
    """Format a temperature: integer when whole, else one decimal."""
    if temp == int(temp):
        return str(int(temp))
    return f"{temp:.1f}"
